\section{Tractograf\'ia}

Dipy es una librer\'ia para python que contiene, entre otras herramientas,
varios algor\'itmos para generar \textit{streamlines}. Un \textit{streamline} es
uno de los posibles caminos que puede realizar una particula, comenzando desde una
semilla en la materia blanca, siguiendo un mapa probabil\'istico de direcciones.
El repetir este experimento es una forma posible de crear tractogramas. Para este
trabajo eleg\'imos utilizar la implementaci\'on de \textit{LocalTracking} (LT de
aqu\'i en mas) que se encuentra en el paquete \textit{dipy.tracking.local}; y 
una implementaci\'on pr\'opia (MSL de aqu\'i en m\'as).\\ . Ambos algoritmos
poseen una estructura similar: Encuadran la imagen de difusi\'on en un modelo;
Crean un objeto que les permita seleccionar una direcci\'on hacia donde moverse
en base a la posici\'on actual; Se mueven hasta cumplir un criterio de parada.\\

En ambos casos encuadramos la informaci\'on de dMRI dentro del modelo
\textit{Constrained Spherical Deconvolve Model}. La principal diferencia surge
en la forma en que seleccionan c\'omo avanzar. Dado el conjunto de direciones 
iniciales, esto es, las direcciones posibles a tomar desde la semilla,
LT intenta en sucesivas repeticiones del experimento elegir una distinta, 
usando as\'i todas al menos una vez. MSL por otro lado selecciona una al
azar cada vez que repite el experimento. A su vez, LT utiliza un criterio de 
parada basado en la FA del tejido; MSL usa una mascara ya predefinida. Para 
mayores detalles referirse al Anexo\\

Para determinar si los algoritmos se estabilizaban y el n\'umero de particulas
necesario para que eso suceda utilizamos la t\'ecnica estad\'istica de
\textit{bootstrap} \cite{Efron1982}. Bootstrap es una forma de aproximar la
distribuci\'on del muestreo de un estad\'istico en base a calcular el mismo
utilizando sucesivos remuestreos de los datos con repeticiones. Esto es
especialmente \'util cuando el n\'umero de muestras que se posee de la poblaci\'on
no es significativamente alto. \\

En nuestro caso situamos setecientas semillas en el \'Area de Broca y luego
generamos quince mil streamlines por cada una. Luego calculamos el tractograma
medio y la varianza de cada voxel utilizando mil submuestras aleator\'ias del
mismo tama\~o. Esto se repitio\'o con varios tama\~nos de submuestra para estudiar
as\'i la variabilidad a medida que la cantidad de part\'iculas crec\'ia. Luego 
de determinar que quince mil part\'iculas era un n\'umero adecuado paralelizamos
la creaci\'on de los streamlines sobre el cluster.\\

Finalmente generamos los tractogramas de cada semilla calculando la frecuencia
de streamlines que pasaron por cada voxel del cerebro. Para almacenar los mismos
intentamos en principio crear un archivo de tipo \textit{Nifti} por cada uno.
El problema de este m\'etodo es que el acceder a los mismos luego requiere volver
a leerlos secuencialmente. El segundo intento fue redimensionar los tractogramas 
a un vector y almacenar una matriz con todos ellos. Sucede que si bien esto es
posible para regiones peque\~nas, no escala cuando uno quiere utilizarlo en toda
la corteza. La soluci\'on fue utilizar matrices ralas para almacenar todos los 
tractogramas al mismo tiempo en un solo archivo. 



\textbf{notebook: Tractograf\'ia probabil\'istica.}

\subsection{Estabilidad Algoritmos}


